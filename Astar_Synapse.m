function optimal_path = Astar_Synapse(BW, Source, R, Neurons, Goal, thetas, ...
                                    fill_gap, theta_thre, Start)

[MAX_Y, MAX_X] = size(BW);
num = size(Neurons, 1);

xStart = Start(1);
yStart = Start(2);

Target = Neurons(Goal, :);
xTarget = Target(1);
yTarget = Target(2);

R_compare = 1.25 * R';
R_compare(Source) = 1.0 * R(Source);

OPEN = [];

% Put all background points on the Closed list
[close_y, close_x] = find(~BW);

CLOSED = [close_x, close_y];
CLOSED_COUNT = size(CLOSED, 1);
% set the starting node as the first node
xNode = xStart;
yNode = yStart;
OPEN_COUNT = 1;
% path cost = 0
path_cost = 0;
parent_index = 1;
goal_distance = distance(xNode, yNode, xTarget, yTarget);
OPEN(OPEN_COUNT, :) = insert_open(xNode, yNode, parent_index, ...
                                path_cost, goal_distance, goal_distance);
former_theta = thetas(yNode, xNode);
% remove from list
OPEN(OPEN_COUNT, 1) = 0;
CLOSED_COUNT = CLOSED_COUNT + 1;
CLOSED(CLOSED_COUNT, :) = [xNode, yNode];

NoPath = 1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% START ALGORITHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
while true
%     dis = sqrt(sum((repmat([xNode, yNode], num, 1) - Neurons) .^ 2, 2));
    dis = sqrt(sum(([xNode, yNode] - Neurons(Goal, :)) .^ 2, 2));
    exp_array = [];
    if dis < R_compare(Goal)
        NoPath = 0;
        break;
%     if max(dis < R_compare)
%         Reach = find(dis < R_compare);
%         if Reach == Goal
%             NoPath = 0;
%             break;
%         end
    else
        exp_array = expand_array(xNode,yNode,path_cost,xTarget,yTarget,CLOSED,...
                           MAX_X,MAX_Y, former_theta, thetas, fill_gap, theta_thre);
    end
    exp_count = size(exp_array,1);
    %UPDATE LIST OPEN WITH THE SUCCESSOR NODES
    %OPEN LIST FORMAT
    %--------------------------------------------------------------------------
    %IS ON LIST 1/0 | X val | Y val | Parent index | |h(n) |g(n)|f(n)|
    %--------------------------------------------------------------------------
    %EXPANDED ARRAY FORMAT
    %--------------------------------
    %| X val | Y val | h(n) | g(n) | f(n) |
    %--------------------------------
    for i = 1 : exp_count
        % whether expanded point in OPEN list
        exp_point = exp_array(i, :);
        Isopen = ismember(exp_point(1:2), OPEN(:,2:3), 'rows');
        if Isopen
            index_open = find(ismember(OPEN(:,2:3), exp_point(1:2), 'rows'));
            if exp_point(5) < OPEN(index_open, 7)
                OPEN(index_open, 4:7) = [OPEN_COUNT, exp_point(3:end)];
            end
        else
            OPEN_COUNT = OPEN_COUNT + 1;
            OPEN(OPEN_COUNT, :) = insert_open(exp_point(1), exp_point(2), ...
                                              parent_index, exp_point(3), ... 
                                              exp_point(4), exp_point(5));
        end%End of insert new element into the OPEN list
    end%End of i for
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%END OF WHILE LOOP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Find out the node with the smallest fn 
    index_min_node = min_fn(OPEN, OPEN_COUNT, xTarget, yTarget);
    former = [xNode, yNode];
    if (index_min_node ~= -1)    
    %Set xNode and yNode to the node with minimum fn
        xNode = OPEN(index_min_node, 2);
        yNode = OPEN(index_min_node, 3);
        former_theta = atan2d(yNode - former(2), ...
                        xNode - former(1));
        path_cost = OPEN(index_min_node, 5);%Update the cost of reaching the parent node
        %Move the Node to list CLOSED
        parent_index = index_min_node;
        CLOSED_COUNT = CLOSED_COUNT + 1;
        CLOSED(CLOSED_COUNT, :) = [xNode, yNode];
        OPEN(index_min_node, 1) = 0;
         plot(xNode,yNode, 'g+');
    else
        %No path exists to the Target!!
        %Exits the loop!
        break;
    end%End of index_min_node check
end%End of While Loop

%Once algorithm has run The optimal path is generated by starting of at the
%last node(if it is the target node) and then identifying its parent node
%until it reaches the start node.This is the optimal path

if NoPath
    optimal_path = [];
    fprintf('Fail to find path');
else
    % last point in CLOSED as terminal
    terminal = CLOSED(end, :);
    optimal_path = terminal;
    path_len = 1;
    node_index = ismember(OPEN(:, 2:3), terminal, 'rows');
    % parent node of terminal
    parent = OPEN(node_index, 4);
    % path
    while OPEN(parent, 2:3) ~= Start
        % add current point
        path_len = path_len + 1;
        optimal_path(path_len, :) = OPEN(parent, 2:3);
        % find parent of current point
        parent = OPEN(parent, 4);
    end
% %Plot the Optimal Path!
%     p = plot(optimal_path(end, 1), optimal_path(end, 2), 'bo');
%     for i = path_len - 1 : -1 : 1
%         pause(.25);
%         set(p, 'XData', optimal_path(i,1), 'YData', optimal_path(i,2));
%         drawnow;
%     end
%     plot(optimal_path(:,1), optimal_path(:, 2));
end